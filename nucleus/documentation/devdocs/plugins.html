<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<!-- $Id$ -->
	<title>Nucleus - Plugin API</title>
	<link rel="stylesheet" type="text/css" href="styles/manual.css" />
	<style type="text/css">
		/* refence parameters (greenish) */
		.ref {
			background-color: #afa;
			color: #000;
		}

		/* object parameters */
		.obj {
			color: #00f;
		}
		.obj:after {
			content: " (object)";
		}

		/* read-only parameters (non-ref; reddish) */
		.ro {
			background-color: #faa;
			color: #000;
		}
	</style>
</head>
<body>

<div class="heading">
Plugin API
<i>December 7, 2010</i>
</div>

<div class="note"><strong>Notes:</strong>
	<ul>
		<li>This document should contain enough information to write basic plugins. If you have more questions, see the <a href="http://forum.nucleuscms.org/viewforum.php?f=10">Plugin Development Forum</a></li>
		<li>Methods and events introduced after Nucleus v1.5 was released have the Nucleus version in which they were introduced listed. If you use any of those functions, don't forget to adapt <code>getMinNucleusVersion</code> appropriately.
		</li>
  </ul>
</div>

<h1>Introduction</h1>

<p>
<a href="index.html">Back to the developer docs index</a>
</p>

<p>
This document contains information on how you can write your own Nucleus plugins
</p>

<h1><a name="toc"></a><a name="top"></a>Table Of Contents</h1>

<ul>
	<li><a href="#introduction">Introduction</a></li>
	<li><a href="#firstplug">Writing your first plugin</a></li>
	<li><a href="#nucleusplugin">Overview of the <code>NucleusPlugin</code> class</a></li>
	<li><a href="#skinvars">The <code>&lt;%plugin(...)%&gt;</code> skinvar</a></li>
	<li><a href="#templatevars">The <code>&lt;%plugin(...)%&gt;</code> templatevar</a></li>
	<li><a href="#actions">Actions using <code>action.php</code></a></li>
	<li><a href="#events">Events, and subscribing to them</a></li>
	<li><a href="#options">Saving options</a></li>
	<li><a href="#tables">Database tables</a></li>
	<li><a href="#admin">Providing an admin area</a></li>
	<li><a href="#help">Providing a helppage</a></li>
	<li><a href="#dependency">Plugin Dependency Check</a></li>
	<li><a href="#internationalization">Internationalizing a Plugin</a></li>
	<li><a href="#skinvar-formatting">Formatting Output of SkinVars</a></li>
	<li><a href="#additional-reading">Additional Reading</a></li>
<!--	<li><a href="#parser">Using the <code>PARSER</code> class</a></li>	
	<li><a href="#"></a></li>
	<li><a href="#"></a></li>
	<li><a href="#"></a></li>-->
</ul>

<h1>Introduction <a name="introduction" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>
Nucleus plugins allow just about anyone to extend the functionality that Nucleus offers, without having to alter the PHP code itself. Plugins are simple php scripts that must implement certain methods, and can easily be exchanged between Nucleus users. Installing goes as easy as adding the plugin file to the plugin directory and letting Nucleus know it's there.
</p>

<p>
Some advantages of plugins are listed below:
</p>

<ul>
	<li>Extra functionality can easily be added to the Nucleus framework, without having to know much details about the implementation.</li>
	<li>You can install only the plugins you need, saving on the time needed to generate a page</li>
</ul>

<p>
All plugin files should be placed in the directory that is listed in <code>config.php</code>. Commonly, this will be <code>/your/path/nucleus/plugins/</code>. Plugin files can be recognized by their form: <code>NP_<i>name</i>.php</code>. Some plugins require a subdirectory with the same <i>name</i> to store extra files or their admin area.
</p>

<div class="note">
<b>Note:</b> the names are case-sensitive, so they should start with <code>NP_</code>, not <code>Np_</code> or <code>np_</code>. Also note that when the plugin uses a subdirectory, the name of that directory should be <em>all lowercase</em>.
</div>




<h1>Writing your first plugin <a name="firstplug" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>
Ok, lets start by writing a simple plugin. Basically, each plugin is a PHP class that inherits from the predefined class <code>NucleusPlugin</code>. Below is an example of a <code>HelloWorld</code>-plugin:
</p>

<pre class="example"><code>&lt;?php

class NP_HelloWorld extends NucleusPlugin
{
	// name of plugin
	function getName()
	{
		return 'Hello World';
	}

	// author of plugin
	function getAuthor()
	{
		return 'Wouter Demuynck';
	}

	// an URL to the plugin website
	// can also be of the form mailto:foo@bar.com
	function getURL()
	{
		return 'http://nucleuscms.org/';
	}

	// version of the plugin
	function getVersion()
	{
		return '1.0';
	}

	// a description to be shown on the installed plugins listing
	function getDescription()
	{
		return 'Just a sample plugin.';
	}

	function doSkinVar($skinType)
	{
		echo 'Hello World!';
	}

	function supportsFeature ($what)
	{
		switch ($what)
		{
			case 'SqlTablePrefix':
				return 1;
			case 'SqlApi':
				return 1;
			default:
				return 0;
		}
	}

}
?&gt;</code></pre>

<ol>
	<li>
		Copy this code in a file called <code>NP_HelloWorld.php</code>, and put it in your plugins directory. <em>Make sure that there are no spaces after the last <code>?&gt;</code> or before the first <code>&lt;?php</code>.</em>. NP stands for "Nucleus Plugin", if you were wondering about that.
	</li>
	<li>Open the Nucleus Administration area and go into <em>Nucleus Management/Manage Plugins</em></li>
	<li>You'll find out that there's a <em>HelloWorld</em> plugin you can install. Do this. If everything worked out correctly, you'll see that your plugin is now listed in the list of installed plugins.</li>
	<li>
		Now edit one of your skins and insert the following statement at a place of which you know where it will show up on the actual page.
<pre class="example"><code>&lt;%HelloWorld%&gt;</code></pre>
		Note that the name (<code>HelloWorld</code>) is case sensitive!
	</li>
	<li>Now visit a page that uses the skin you edited: notice the "Hello World" at the location where you've added the <code>plugin</code>-skinvar.</li>
</ol>

<p>
So, that wasn't so hard after all. Read on to find out more.
</p>







<h1>The class NucleusPlugin <a name="nucleusplugin" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>All Nucleus plugins must inherit from the PHP class <code>NucleusPlugin</code>. If this sounds complicated, don't worry, it isn't. It even makes your life easier, allowing you to only implement the methods that your plugin needs, and giving access to some auxiliary functions.</p>

<p>Below is an overview of the methods that the <code>NucleusPlugin</code> offers, and that you can re-implement in your own plugin. If you want to see the source of the class itsself, it's located at <code>nucleus/libs/PLUGIN.php</code></p>

<table summary="An overview of the redefinable methods in the class NucleusPlugin">
	<caption>Overview of the class <code>NucleusPlugin</code> (redefinable methods)</caption>
	<tr>
		<th>Method&nbsp;Signature</th><th>Explanation</th>
	</tr>
	<tr>
		<td><code>getName()</code></td>
		<td>Returns the name of the plugin. This will be the name that will show up on the list of installed plugins. You should definately redefine this method, since the default implementation returns <q>Undefined</q></td>
	</tr>
	<tr>
		<td><code>getAuthor()</code></td>
		<td>Returns the name of author of the plugin. This name will show up on the list of installed plugins. You should definately redefine this method, since the default implementation returns <q>Undefined</q></td>
	</tr>
	<tr>
		<td><code>getURL()</code></td>
		<td>Returns the URL of the site where the plugin can be downloaded, or where additional information about the plugin can be found. If no such site exists, a <code>mailto:</code>-link with the authors email address is appropriate. You should definately redefine this method, since the default implementation returns <q>Undefined</q></td>
	</tr>
	<tr>
		<td><code>getDescription()</code></td>
		<td>Returns a longer description of the plugin. This will show up on the list of installed plugins. The default implementation returns <q>Undefined</q></td>
	</tr>
	<tr>
		<td><code>getVersion()</code></td>
		<td>Returns the current version of the plugin. Returns <q>0.0</q> by default</td>
	</tr>
	<tr>
		<td><code>getMinNucleusVersion()</code></td>
		<td>(v2.0b) Returns the minimum required Nucleus version. By default, this returns <code>155</code> (v1.55). If you are using plugin features that were introduced later, please implement this function (e.g. v2.0 => 200). Please note that Nucleus v1.55 does not use this function at all, so it remains possible to install newer plugins there, even if they use newer features.</td>
	</tr>
	<tr>
		<td><code>getMinNucleusPatchLevel()</code></td>
		<td>(v3.1) Returns the minimum required Nucleus patch level that needs to be present when running the minimal required Nucleus version (<code>getMinNucleusVersion</code>). By default, this returns <code>0</code>. This function is generally used when new plugin features are available only as patches to the latest released Nucleus version.</td>
	</tr>
	<tr>
		<td><code>init()</code></td>
		<td>Initializes the plugin. This method gets called immediately after the plugin object is created and the <code>plugid</code>-attribute has been set. By default, this method does nothing.</td>
	</tr>
	<tr>
		<td><code>doSkinVar($skinType)</code></td>
		<td>When plugins are called using the <code>&lt;%plugin(...)%&gt;</code>-skinvar, this method will be called. the <code>$skinType</code> parameter contains the type of skin (<code>item</code>, <code>archive</code>, ...) from where the plugin is called. Don't get confused by the fact that there's only one parameter. Multiple parameters <strong>can</strong> still be passed. <a href="#skinvars">More info on implementing the <code>doSkinVar</code> method.</a> By default, this method does no output at all.</td>
	</tr>
	<tr>
		<td><code>doTemplateVar(&amp;$item)</code></td>
		<td>Basically the same as <code>doSkinVar</code>, but this time for calls of the &lt;%plugin(...)%&gt;-var in <i>templates</i> (item header/body/footer and dateheader/footer). By default, this method forwards the handling to the <code>doSkinVar</code>-method, using <code>template</code> as skintype. <a href="#templatevars">More information on implementing the <code>doTemplateVar</code> method</a></td>
	</tr>
	<tr>
		<td><code>doTemplateCommentsVar(&amp;$item, &amp;$comment)</code></td>
		<td>(v2.0b) Basically the same as <code>doSkinVar</code>, but this time for calls of the &lt;%plugin(...)%&gt;-var in <i>templates</i> (comments-related parts). By default, this method forwards the handling to the <code>doSkinVar</code>-method, using <code>template</code> as skintype. <a href="#templatevars">More information on implementing the <code>doTemplateCommentsVar</code> method</a></td>
	</tr>
	<tr>
		<td><code>doItemVar(&amp;$item)</code></td>
		<td>(v3.30) Basically the same as <code>doSkinVar</code>, but this time for calls of the &lt;%plugin(...)%&gt;-var in an <i>item</i>. <code>&amp;$item</code> provides the full item object of the item in which the ItemVar appears. ItemVar parameters are handled the same way as SkinVar parameters.</td>
	</tr>
	<tr>
		<td><code>doIf($key, $value)</code></td>
		<td>(v3.30) Evaluates a custom conditional statement for the <code>if/ifnot/elseif/elseifnot</code> skin variables. Must return either <code>true</code> or <code>false</code>. $key and $value are strings passed from the <code>if/ifnot/elseif/elseifnot</code> skin variable. Normally, the plugin should check whether <code>$key</code> has the value of <code>$value</code>, but other uses are possible. Plugins that make use of this method, should document its use for users of the plugin.</td>
	</tr>
	<tr>
		<td><code>doAction($type)</code></td>
		<td>When a plugin wants to allow user interaction, it can allow actions through <code>action.php</code>. This is the script that Nucleus uses itself to handle new comments and karma votes. Called with the correct parameters, the <code>doAction</code>-method from a plugin can be called. The <code>$type</code> contains an optional message type. Extra variables from the request can be accessed from within the <code>doAction</code> method. By default, this method returns a string <q>No Such Action</q> which will trigger an error message. <a href="#actions">More info on <code>doAction</code>.</a></td>
	</tr>
	<tr>
		<td><code>install()</code></td>
		<td>This method gets called on the moment the plugin is installed. It can perform initializing actions, such as the creation of database tables, the creation of plugin options, etc... By default, this method does nothing.</td>
	</tr>
	<tr>
		<td><code>unInstall()</code></td>
		<td>Called when the plugin is uninstalled. It's a good thing to clean up information your plugin created in the database at this point. By default, this method does nothing.</td>
	</tr>
	<tr>
		<td><code>getEventList()</code></td>
		<td>Plugins can subscribe to events. Events get generated whenever Nucleus performs a certain action. An <code>AddItem</code> event for example, will call all plugins that subscribed to this event. The called method will be <code>event_AddItem($params)</code>. The <code>$params</code>-parameter is an associative array containing several fields of information, like the itemid for <code>AddItem</code>. Returns an empty array by default, indicating that the plugin does not subscribe to any event at all. <a href="#events">More information about events.</a></td>
	</tr>
	<tr>
		<td><code>getTableList()</code></td>
		<td>This method should return an array of database tables that the plugin has created. It's used in the backup feature that Nucleus offers, so plugin tables are also included in the backup. By default, returns an empty array.</td>
	</tr>
	<tr>
		<td><code>hasAdminArea()</code></td>
		<td>Should return <code>1</code> if the plugin has an admin area of its own, and <code>0</code> if it doesn't. By default, <code>0</code> is returned.</td>
	</tr>
	<tr>
		<td><code>getPluginDep()</code></td>
		<td>(v3.2) Returns an array of plugin names. Nucleus refuses to install the plugin if any of these plugins is not installed. By default, an empty array is returned. <a href="#dependency">More information on plugin dependencies.</a></td>
	</tr>
</table>

<p>Next to the methods that can be implemented, the class <code>NucleusPlugin</code> offers some extra methods which you <em>should not</em> implement yourself. They can be called from within your plugin using the <code>$this-&gt;functionName()</code> syntax.</p>

<table summary="An overview of the auxiliary methods in the class NucleusPlugin. You should NOT redefine these">
	<caption>Overview of the class <code>NucleusPlugin</code> (non-redefinable methods)</caption>
	<tr>
		<th>Method&nbsp;Signature</th><th>Explanation</th>
	</tr>
	<tr>
		<td>
				  <code>createOption(...)</code>
			<br /><code>createBlogOption(...)</code>(v2.2)
			<br /><code>createCategoryOption(...)</code>(v2.2)
			<br /><code>createMemberOption(...)</code>(v2.2)
	  <br /><code>createItemOption(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">Creates a new option</a></td>
	</tr>
	<tr>
		<td>
				  <code>deleteOption(...)</code>
			<br /><code>deleteBlogOption(...)</code>(v2.2)
			<br /><code>deleteCategoryOption(...)</code>(v2.2)
			<br /><code>deleteMemberOption(...)</code>(v2.2)
	  <br /><code>deleteItemOption(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">Deletes an option</a></td>
	</tr>
	<tr>
		<td>
				  <code>setOption(...)</code>
			<br /><code>setBlogOption(...)</code>(v2.2)
			<br /><code>setCategoryOption(...)</code>(v2.2)
			<br /><code>setMemberOption(...)</code>(v2.2)
	  <br /><code>setItemOption(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">Sets the value of an option</a></td>
	</tr>
	<tr>
		<td>
				  <code>getOption(...)</code>
			<br /><code>getBlogOption(...)</code>(v2.2)
			<br /><code>getCategoryOption(...)</code>(v2.2)
			<br /><code>getMemberOption(...)</code>(v2.2)
	  <br /><code>getItemOption(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">Retrieves the value of an option</a></td>
	</tr>
	<tr>
		<td>
			<code>getAllBlogOptions(...)</code>(v2.2)
			<br /><code>getAllCategoryOptions(...)</code>(v2.2)
			<br /><code>getAllMemberOptions(...)</code>(v2.2)
	  <br /><code>getAllItemOptions(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">For a given option, returns an associative of all values (one value per context)</a></td>
	</tr>

  <tr>
		<td>
			<code>getBlogOptionTop(...)</code>(v3.2)
			<br /><code>getMemberOptionTop(...)</code>(v3.2)
			<br /><code>getCategoryOptionTop(...)</code>(v3.2)
	  <br /><code>getItemOptionTop(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">For a given option, returns the top of all values</a></td>
	</tr>
	<tr>
		<td><code>getID()</code></td>
		<td>Returns the ID for this plugin (this is the ID internally used inside Nucleus)</td>
	</tr>
	<tr>
		<td><code>getAdminURL()</code></td>
		<td>Returns the URL of where the admin area of the plugin is located (if there is no such admin area, this information is invalid)</td>
	</tr>
	<tr>
		<td><code>getDirectory()</code></td>
		<td>Returns the path in the servers filesystem where the extra files for the plugin are stored (if there are no such files, this information makes no sense). The result is something like "<code>.../nucleus/plugins/<i>plugname</i>/</code>"</td>
	</tr>
	<tr>
		<td><code>getShortName()</code></td>
		<td>Returns the part of the plugin classname without the "<code>NP_</code>"-part, and in all-lowercase. This information is used in the functions <code>getAdminURL</code> and <code>getDirectory</code></td>
	</tr>

</table>

<h1>Skinvars <a name="skinvars" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>Description</h2>

<p>
You can create your own skinvars, and call them using <code>&lt;%plugin(<i>PlugName</i>,<i>parameters</i>)%&gt; </code> or <code>&lt;%PlugName(parameters)%&gt;</code> (when this does not conflict with an existing skinvar). Parameters are comma-separated.
</p>

<p>
To handle skinvars, you'll need to implement the <code>doSkinVar</code> method. Some samples of signatures are given below:
</p>

<pre class="example"><code>function doSkinVar($skinType)
function doSkinVar($skinType, $param1, $param2)
function doSkinVar($skinType, $skinVar, $param1, $param2)
function doSkinVar($skinType, $skinVar, $param1 = 'default value')</code></pre>

<ul>
	<li>The <code>$skinType</code> parameter will be one of 'index', 'item', 'archive', 'archivelist', 'member', 'error', 'search', 'imagepopup' or <a href="#templatevars" title="Information on templatevars">'template'</a></li>
	<li>The <code>$skinVar</code> is actually the first parameter that's being interpreted as a type of skinvar (e.g. <code>&lt;%plugin(PlugName,VarType)%&gt;</code>)</li>
	<li>You can use <code>doSkinVar()</code> (no parameters) and retrieve the parameters using the PHP function <code>func_get_args()</code>. Could be handy if you have different types of skinvars with different numbers of arguments</li>
</ul>

<h2>Notes</h2>

<ul>
	<li>(v2.0b) You can find the name of the skin that's currently being parsed in the global variable <code>$currentSkinName</code></li>
</ul>




<h1>Template variables <a name="templatevars" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>Description</h2>

<p>
Template plugin variables work in the same way as skin plugin vars. There are two differences:</p>

<ol>
	<li>They are called from within templates instead of from within skins</li>
	<li>They don't take a <code>$skinType</code> parameter. Instead, they take extra parameters with info on the item and comment that is currently being parsed:
		<ul>
			<li>The <code>doTemplateVar</code>-method gets a <code>&amp;$item</code> parameter.</li>
			<li>The <code>doTemplateCommentsVar</code>-method gets an <code>&amp;$item</code> parameter as well as a <code>&amp;$comment</code> parameter.</li>
		</ul>
		<strong>Note the ampersands!</strong>
	</li>
</ol>

<p>Template variables are called in exactly the same way as skinvars (using <code>&lt;%plugin(<i>PlugName</i>,<i>parameters</i>)%&gt; </code> or <code>&lt;%PlugName(parameters)%&gt;</code>)
</p>

<p>
By default, all template variables are passed on to the <code>doSkinVar</code>-method, using '<code>template</code>' as <code>skinType</code>-parameter.
</p>

<p>
If you want to provide your own implementation, you'll need to redefine the method <code>doTemplateVar</code> and/or <code>doTemplateCommentsVar</code>. It works in the same way as <code>doSkinVar</code>, except that now the <code>skinType</code>-parameter is missing.
</p>

<pre class="example"><code>function doTemplateVar(&amp;$item)
function doTemplateVar(&amp;$item, $param1, $param2)
function doTemplateVar(&amp;$item, $type, $param1, $param2)
function doTemplateVar(&amp;$item, $type, $param1 = 'default value')
function doTemplateCommentsVar(&amp;$item, &amp;$comment)
function doTemplateCommentsVar(&amp;$item, &amp;$comment, $param1, $param2)
function doTemplateCommentsVar(&amp;$item, &amp;$comment, $type, $param1, $param2)
function doTemplateCommentsVar(&amp;$item, &amp;$comment, $type, $param1 = 'default value')</code></pre>

<h2>Notes</h2>

<ul>
	<li>(v2.0b) You can find the name of the template that's currently being used inside the global variable <code>$currentTemplateName</code></li>
</ul>




<h1>Actions <a name="actions" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>Plugins can perform actions through <code>action.php</code>, the same script that's being used to receive comments and karma votes. You can call it using both GET and POST methods. Required parameters are <code>action</code> (should be 'plugin'), <code>name</code> (name of the plugin) and <code>type</code> (type of requested action)</p>

<p>To enable these actions, you should implement the <code>doAction($actionType)</code> method in your plugin. Extra parameters from the request can be received using <code>requestVar('<i>name</i>')</code> (<code>requestVar</code> takes care of magic_quotes_gpc that PHP might have added)</p>

<p>
When your <code>doAction</code> method returns a string, it will be interpreted as an error, and an error message will be shown.
</p>






<h1>Events <a name="events" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>
Nucleus Plugins can subscribe to events that occur whenever something important happens. The plugin can then execute some actions, or output some text.
</p>

<h2>Example</h2>

<p>
Below is an example of how a plugin subscribes to the <code>PreAddComment</code>-event, an event that is generated immediately before a comment is added to a blog.
</p>

<pre class="example"><code>class NP_Acronyms extends NucleusPlugin {
  ...
  function getEventList() { return array('PreAddComment'); }
  ...
  function event_PreAddComment(&amp;$data) {
	// replace acronym HTML
	$data['comment']['body'] =
		strreplace('HTML',
				   '&lt;acronym title="HyperText Markup Language"&gt;HTML&lt;/acronym&gt;',
				   $data['comment']['body']);
  }
}
</code></pre>

<p>This plugin replaces the text <code>HTML</code> in each comment by the text <code>&lt;acronym title="HyperText Markup Language"&gt;HTML&lt;/acronym&gt;</code>. The <code>acronym</code>-tag is a <acronym title="HyperText Markup Language">HTML</acronym>-tag that allows authors to provide extra information on acronyms.</p>

<h2>Subscribing to events</h2>

<p>Here's the steps you need to take to subscribe to an event:</p>

<ol>
	<li>Add the event name to the array returned by the <code>getEventList</code>-method</li>
	<li>Create a method with signature <code>event_<em>EventName</em>($data)</code>, in which the handling of the event is done</li>
</ol>

<p>Multiple plugins can subscribe to the same event. The order in which these plugins are notified is the same order as the ordening in the plugin list of the admin area. Plugins higher in the list get notified earlier on.</p>

<h2>Parameters</h2>

<p>The <code>event_<em>EventName</em></code>-method gets only one parameter, <code>$data</code>, of which the contents differs depending on the event. It is an associative array with data. Objects and arrays that are passed in this array, are passed by <strong>reference</strong>, so the changes you make there will be remembered.</p>

<p>The event list below uses some colors to indicate if changes in the parameters will be seen by nucleus or not:</p>

<ul>
	<li><var class="ref">pass-by-reference</var>: when changes are made to this kind of parameters, they will be seen by Nucleus.</li>
	<li><var class="ro">pass-by-value</var>: a copy of the value is made before it is sent to the plugin event handler. Changes in the contents of these variables will be discarded automatically.</li>
</ul>

<p>Objects that are passed as parameters are indicates as follows: <var class="obj">object</var>. Most objects are also passed by reference, making them look like <var class="obj ref">object by ref</var></p>

<h2>Event List</h2>

<table summary="An overview of events to which a Nucleus Plugin can subscribe, and what parameters are passed along to the method that handles the event">
	<caption>Events on which a plugin can subscribe</caption>
	<tr>
		<th>Name</th><th>When</th><th>Parameters</th>
	</tr>
	<tr>
		<td>InitSkinParse</td>
		<td>Just before the skin is initialized</td>
		<td><dl>
			<dt class="obj ref">skin</dt>
			<dd>The <code>SKIN</code>-object that is handling the parse</dd>
			<dt class="ro">type</dt>
			<dd>Type of skinpart (one of 'index', 'item', 'archive', 'archivelist', 'member', 'error', 'search', 'imagepopup', 'fileparser')</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreSkinParse</td>
		<td>Immediately before the parsing of a skin begins</td>
		<td><dl>
			<dt class="obj ref">skin</dt>
			<dd>The <code>SKIN</code>-object that is handling the parse</dd>
			<dt class="ro">type</dt>
			<dd>Type of skinpart (one of 'index', 'item', 'archive', 'archivelist', 'member', 'error', 'search', 'imagepopup', 'fileparser')</dd>
			<dt class="ref">contents</dt>
			<dd>The content of the skin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostSkinParse</td>
		<td>Immediately after parsing a skin</td>
		<td><dl>
			<dt class="obj ref">skin</dt>
			<dd>The <code>SKIN</code>-object that is handling the parse</dd>
			<dt class="ro">type</dt>
			<dd>Type of skinpart (one of 'index', 'item', 'archive', 'archivelist', 'member', 'error', 'search', 'imagepopup', 'fileparser')</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreItem</td>
		<td>Before an item is parsed, but after the item header has been placed</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ref obj">item</dt>
			<dd>object containing item data</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostItem</td>
		<td>After an item has been parsed, but before the item footer has been parsed</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ref obj">item</dt>
			<dd>object containing item data</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreComment</td>
		<td>Before a comment is shown</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>associative array containing comment data</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostComment</td>
		<td>After a comment has been shown</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>associative array containing comment data</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDateHead</td>
		<td>Before a date header is shown</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ro">timestamp</dt>
			<dd>Timestamp for date header</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDateHead</td>
		<td>After a date header has been parsed</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ro">timestamp</dt>
			<dd>Timestamp for date header</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDateFoot</td>
		<td>Before a date footer is parsed</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ro">timestamp</dt>
			<dd>Timestamp for day that is closed</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDateFoot</td>
		<td>After a date footer has been parsed</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ro">timestamp</dt>
			<dd>Timestamp for day that is closed</dd>
		</dl></td>
	</tr>
	<tr>
		<td>LoginSuccess</td>
		<td>After a successful login</td>
		<td><dl>
			<dt class="obj ref">member</dt>
			<dd><code>MEMBER</code> object</dd>
			<dt class="ro">username</dt>
			<dd>login name that was used in the login attempt</dd>
		</dl></td>
	</tr>
	<tr>
		<td>LoginFailed</td>
		<td>After a failed login</td>
		<td><dl>
			<dt class="ro">username</dt>
			<dd>login name that was used in the login attempt</dd>
		</dl></td>
	</tr>
	<tr>
		<td>Logout</td>
		<td>After logout</td>
		<td><dl>
			<dt class="ro">username</dt>
			<dd>name of the user that logged out</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreBlogContent</td>
		<td>Before blog content has been inserted through a skinvar</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ro">type</dt>
			<dd>Type of skinvar that's being called ('blog', 'otherblog', 'archive', 'archivelist', 'item', 'searchresults', 'othersearchresults', 'categorylist', 'otherarchive', 'otherarchivelist')</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostBlogContent</td>
		<td>After blog content has been inserted through a skinvar</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ro">type</dt>
			<dd>Type of skinvar that's being called ('blog', 'otherblog', 'archive', 'archivelist', 'item', 'searchresults', 'othersearchresults', 'categorylist', 'otherarchive', 'otherarchivelist')</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddComment</td>
		<td>Before adding a comment to the database</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>comment data (associative array)</dd>
			<dt class="ref">spamcheck</dt>
			<dd>the resulting datastructure of the previously called <code>SpamCheck</code> event (associative array)</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddComment</td>
		<td>After adding a comment to the database</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>comment data (associative array)</dd>
			<dt class="ref">commentid</dt>
			<dd>comment ID</dd>
			<dt class="ref">spamcheck</dt>
			<dd>the resulting datastructure of the previously called <code>SpamCheck</code> event (associative array)</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostRegister</td>
		<td>After a new user has registered</td>
		<td><dl>
			<dt class="obj ref">member</dt>
			<dd>New <code>MEMBER</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddItem</td>
		<td>After an item has been added to the database</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>new itemid in database</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostUpdateItem</td>
		<td>Immediately after an item gets updates in the database</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>item ID</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddItem</td>
		<td>Immediately before an item is added to the database</td>
		<td><dl>
			<dt class="ref">title</dt>
			<dd>title</dd>
			<dt class="ref">body</dt>
			<dd>body text</dd>
			<dt class="ref">more</dt>
			<dd>extended text</dd>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ref">authorid</dt>
			<dd>ID of author</dd>
			<dt class="ref">timestamp</dt>
			<dd>UNIX timestamp</dd>
			<dt class="ref">closed</dt>
			<dd>1 (no comments allowed) or 0 (comments allowed)</dd>
			<dt class="ref">draft</dt>
			<dd>1 (draft) or 0 (not draft)</dd>
			<dt class="ref">catid</dt>
			<dd>ID fo category</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreUpdateItem</td>
		<td>Immediately before an item gets updates in the database</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>item ID</dd>
			<dt class="ref">title</dt>
			<dd>title</dd>
			<dt class="ref">body</dt>
			<dd>body text</dd>
			<dt class="ref">more</dt>
			<dd>extended text</dd>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ref">closed</dt>
			<dd>1 (no comments allowed) or 0 (comments allowed)</dd>
			<dt class="ref">catid</dt>
			<dd>ID fo category</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PrepareItemForEdit</td>
		<td>Called after getting an item from the database, and before presenting it to the user to be edited.</td>
		<td><dl>
			<dt class="ref">item</dt>
			<dd>associative array containing item data</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreUpdateComment</td>
		<td>Immediately before a comment is updated and saved into the database</td>
		<td><dl>
			<dt class="ref">body</dt>
			<dd>Comment body</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PrepareCommentForEdit</td>
		<td>After a comment is retrieved from the database, and before it is presented to the user to be edited.</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>comment data (associative array)</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PrePluginOptionsEdit</td>
		<td>
			(v2.0b) before the 'edit plugin options' form is created.
			<br />(v2.2) extra parameters
	  <br />(v3.2) extra parameter for every option
		</td>
		<td><dl>
			<dt class="ro">context</dt>
			<dd>(v2.2) <code>global</code>, <code>blog</code>, <code>member</code>, <code>item</code> or <code>category</code></dd>
			<dt class="ref">options</dt>
			<dd>Array with for each option an associative array, having the following indices: <code>name</code>, <code>value</code>, <code>oid</code>, <code>description</code>, <code>type</code>, <code>typeinfo</code>, <code>contextid</code>, <code>extra</code>. Extra options can be added here (if you want to do something with them, you'll need to subscribe to PostPluginOptionsUpdate as well)<br />
	  Using the <code>extra</code>-field you can add extra html (by example formcontrols) to the option. If you do so, you should compare <code>pid</code> with <code>getID()</code> and also check <code>name</code> before adding things to <code>extra</code></dd>
			<dt class="ro">plugid</dt>
			<dd>plugin ID (compare with <code>GetID()</code> to find out if this concerns you) (only present when context is global)</dd>
			<dt class="ro">contextid</dt>
			<dd>context ID (blogid, memberid, catid, itemid depending on context)</dd>

		</dl></td>
	</tr>
  <tr>
		<td>PrePluginOptionsUpdate</td>
		<td>
			(v3.2) Before the options for a plugin have been updated. (using this event you can validate/change the new value for an option)
		</td>
		<td><dl>
	  <dt class="ro">context</dt>
			<dd>(v2.2) <code>global</code>, <code>member</code>, <code>blog</code>, <code>item</code> or <code>category</code></dd>
			<dt class="ro">plugid</dt>
			<dd>plugin ID (compare with <code>GetID()</code> to find out if this concerns you)</dd>
	  <dt class="ro">optionname</dt>
			<dd>Name of the option</dd>
			<dt class="ro">contextid</dt>
			<dd>context ID (blogid, memberid, catid, itemid depending on context)</dd>
			<dt class="ref">value</dt>
			<dd>New value for the option</dd>
		</dl></td>

	</tr>

	<tr>
		<td>PostPluginOptionsUpdate</td>
		<td>
			(v2.0b) After the options for a plugin have been updated.
			<br />(v2.2) Different parameters depending on context
		</td>
		<td><dl>
			<dt class="ro">context</dt>
			<dd>(v2.2) <code>global</code>, <code>member</code>, <code>blog</code>, <code>item</code> or <code>category</code></dd>
			<dt class="ro">plugid</dt>
			<dd>plugin ID (compare with <code>GetID()</code> to find out if this concerns you) (global context)</dd>
			<dt class="ro">blogid</dt>
			<dd>(v2.2) blog ID (blog context)</dd>
			<dt class="ref obj">blog</dt>
			<dd>(v2.2) BLOG object (blog context)</dd>
			<dt class="ro">memberid</dt>
			<dd>(v2.2) member ID (member context)</dd>
			<dt class="ref obj">member</dt>
			<dd>(v2.2) MEMBER object (member context)</dd>
			<dt class="ro">catid</dt>
			<dd>(v2.2) category ID (category context)</dd>
	  <dt class="ro">itemid</dt>
			<dd>(v2.2) item ID (item context)</dd>
	  <dt class="ref obj">member</dt>
			<dd>(v2.2) ITEM object (item context)</dd>
		</dl></td>

	</tr>
	<tr>
		<td>PostAuthentication</td>
		<td>(v2.0b) After the login procedure has been completed. This occurs on each page request.</td>
		<td><dl>
			<dt class="ro">loggedIn</dt>
			<dd>result of <code>$member->isLoggedIn()</code></dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddItemForm</td>
		<td>(v2.0b) Immediately before an add item form (bookmarklet or admin area) is created.</td>
		<td><dl>
			<dt class="ref">contents</dt>
			<dd>reference to an associative array, in which the values 'title', 'body' and 'more' can be filled with initial values for the formfields. To avoid multiple plugins to alter these values, set the 'hasBeenSet' value to 1 when you're done (and check for it before starting)</dd>
			<dt class="ref obj">blog</dt>
			<dd>reference to a <code>BLOG</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>AddItemFormExtras</td>
		<td>(v2.0b) Somewhere inside the add item page or bookmarklet. Here, plugins can add their custom fields without having to alter one of the <code>.template</code> files.</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd>reference to a <code>BLOG</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>EditItemFormExtras</td>
		<td>
			(v2.0b) Somewhere inside the edit item page or bookmarklet. Here, plugins can add their custom fields without having to alter one of the <code>.template</code> files.
			<br /><br />
			Don't add too much data, and please generate <strong>valid XHTML</strong>, looking like this:
<pre class="example"><code>&lt;h3&gt;plugin name&lt;/h3&gt;
&lt;p&gt;your stuff&lt;/p&gt;</code></pre>
			This way, multiple plugins can add options here while things keep a good structure. Also try to use prefixes for your fieldnames, in order to avoid nameclashes (e.g. <code>plug_tb_url</code>)
		</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd>reference to a <code>BLOG</code> object</dd>
			<dt class="ro">variables</dt>
			<dd>
				(read-only) An associative array containing all sorts of information on the item that's being edited: 'itemid', 'draft', 'closed', 'title', 'body', 'more', 'author', 'authorid', 'timestamp', 'karmapos', 'karmaneg', 'catid'
			</dd>
			<dt class="ro">itemid</dt>
			<dd>shortcut to the item ID</dd>
		</dl></td>
	</tr>
	<tr>
		<td>BlogSettingsFormExtras</td>
		<td>(v2.0) On the blog settings page. You can add your own forms here.
			<br /><br />
			Don't add too much data, and please generate <strong>valid XHTML</strong>, looking like this:
<pre class="example"><code>&lt;h4&gt;plugin name&lt;/h4&gt;
&lt;form method="post" action="..."&gt;&lt;p&gt;
your stuff
&lt;/p&gt;&lt;/form&gt;</code></pre>
			This way, multiple plugins can add options here while things keep a good structure. Also try to use prefixes for your fieldnames, in order to avoid nameclashes (e.g. <code>plug_tb_url</code>)

		</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd>reference to a <code>BLOG</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteItem</td>
		<td>(v2.0) Immediately before an item gets deleted in the database</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>id of the item that will be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteItem</td>
		<td>(v2.0) Immediately after an item has been deleted in the database</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>id of the deleted item</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteCategory</td>
		<td>(v2.0) Immediately before a category gets deleted from the database</td>
		<td><dl>
			<dt class="ro">catid</dt>
			<dd>category ID</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteCategory</td>
		<td>(v2.0) Immediately after a category has been deleted from the database</td>
		<td><dl>
			<dt class="ro">catid</dt>
			<dd>category ID</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteBlog</td>
		<td>(v2.0) Immediately before a blog gets deleted from the database</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog that will be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteBlog</td>
		<td>(v2.0) Immediately after a blog has been deleted from the database</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog that was deleted from the database</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteMember</td>
		<td>(v2.0) Immediately before a member gets deleted from the database</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd>reference to the <code>MEMBER</code> object associated with the member that needs to be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteMember</td>
		<td>(v2.0) Immediately after a member has been deleted from the database</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd>reference to the <code>MEMBER</code> object associated with the member that has been deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteTeamMember</td>
		<td>(v2.0) Immediately before a member gets deleted from a weblog team</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd>reference to the <code>MEMBER</code> object</dd>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteTeamMember</td>
		<td>(v2.0) Immediately after a member has been deleted from a weblog team</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd>reference to the <code>MEMBER</code> object</dd>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteComment</td>
		<td>(v2.0) Immediately before a comment gets deleted from the database</td>
		<td><dl>
			<dt class="ro">commentid</dt>
			<dd>ID of the comment that will be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteComment</td>
		<td>(v2.0) Immediately after a comment has been deleted from the database</td>
		<td><dl>
			<dt class="ro">commentid</dt>
			<dd>ID of the deleted comment</dd>
		</dl></td>
	</tr>
	<tr>
		<td>ActionLogCleared</td>
		<td>(v2.0) After the action log has been cleared</td>
		<td>None</td>
	</tr>
	<tr>
		<td>PreDeleteTemplate</td>
		<td>(v2.0) Immediately before a template gets deleted from the database</td>
		<td><dl>
			<dt class="ro">templateid</dt>
			<dd>ID of the template that will be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteTemplate</td>
		<td>(v2.0) Immediately after a template has been deleted from the database</td>
		<td><dl>
			<dt class="ro">templateid</dt>
			<dd>ID of the deleted template</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteSkin</td>
		<td>(v2.0) Immediately before a skin gets deleted from the database</td>
		<td><dl>
			<dt class="ro">skinid</dt>
			<dd>ID of the skin that will be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteSkin</td>
		<td>(v2.0) Immediately after a skin has been deleted from the database</td>
		<td><dl>
			<dt class="ro">skinid</dt>
			<dd>ID of the deleted skin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeletePlugin</td>
		<td>(v2.0) Immediately before a plugin gets deleted from the database</td>
		<td><dl>
			<dt class="ro">plugid</dt>
			<dd>ID of the plugin that will be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeletePlugin</td>
		<td>(v2.0) Immediately after a plugin has been deleted from the database</td>
		<td><dl>
			<dt class="ro">plugid</dt>
			<dd>ID of the deleted plugin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteBan</td>
		<td>(v2.0) Immediately before an IP ban gets deleted from the database</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog for which the ban will be deleted</dd>
			<dt class="ro">iprange</dt>
			<dd>banned IP range</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteBan</td>
		<td>(v2.0) Immediately after an IP ban has been deleted from the database</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog for which the ban has been deleted</dd>
			<dt class="ro">iprange</dt>
			<dd>banned IP range</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddCategory</td>
		<td>(v2.0) Immediately before a new category is created in the database</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd>reference to <code>BLOG</code> object</dd>
			<dt class="ref">name</dt>
			<dd>name of new category</dd>
			<dt class="ref">description</dt>
			<dd>description of new category</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddCategory</td>
		<td>(v2.0) Immediately after a new category has been created in the database</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd>reference to <code>BLOG</code> object</dd>
			<dt class="ro">name</dt>
			<dd>name of new category</dd>
			<dt class="ro">description</dt>
			<dd>description of new category</dd>
			<dt class="ro">catid</dt>
			<dd>New category ID</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddBlog</td>
		<td>(v2.0) Immediately before a new blog is created</td>
		<td><dl>
			<dt class="ref">name</dt>
			<dd>name of new blog</dd>
			<dt class="ref">shortname</dt>
			<dd>shortname of new blog</dd>
			<dt class="ref">timeoffset</dt>
			<dd>time offset of new blog</dd>
			<dt class="ref">description</dt>
			<dd>description of new blog</dd>
			<dt class="ref">defaultskin</dt>
			<dd>ID of default skin for new blog</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddBlog</td>
		<td>(v2.0) Immediately after a new blog has been created</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd>new <code>BLOG</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddPlugin</td>
		<td>(v2.0) Immediately before a plugin is added</td>
		<td><dl>
			<dt class="ref">file</dt>
			<dd>filename of the new plugin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddPlugin</td>
		<td>(v2.0) Immediately after a plugin has been added</td>
		<td><dl>
			<dt class="ref obj">plugin</dt>
			<dd>An object of the newly added plugin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddTeamMember</td>
		<td>(v2.0) Immediately before a member gets added to a blog team</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ref obj">member</dt>
			<dd><code>MEMBER</code> object</dd>
			<dt class="ref">admin</dt>
			<dd>boolean indicating if the newly added member will have blog admin rights or not</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddTeamMember</td>
		<td>(v2.0) Immediately after a member has been added to a blog team</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ref obj">member</dt>
			<dd><code>MEMBER</code> object</dd>
			<dt class="ro">admin</dt>
			<dd>boolean indicating if the newly added member has admin rights or not</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddTemplate</td>
		<td>(v2.0) Immediately before a new template is created (note: this one also gets called when a template is cloned))</td>
		<td><dl>
			<dt class="ref">name</dt>
			<dd>name of the new template</dd>
			<dt class="ref">description</dt>
			<dd>description of the new template</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddTemplate</td>
		<td>(v2.0) Immediately after a new template has been created</td>
		<td><dl>
			<dt class="ro">name</dt>
			<dd>name of the new template</dd>
			<dt class="ro">description</dt>
			<dd>description of the new template</dd>
			<dt class="ro">templateid</dt>
			<dd>ID of the new template</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddSkin</td>
		<td>(v2.0) Immediately before a new skin is created (note: this one also gets called when a skin is cloned))</td>
		<td><dl>
			<dt class="ref">name</dt>
			<dd>name of the new skin</dd>
			<dt class="ref">description</dt>
			<dd>description of the new skin</dd>
			<dt class="ref">type</dt>
			<dd>content type of the skin</dd>
			<dt class="ref">includeMode</dt>
			<dd>includeMode of the new skin</dd>
			<dt class="ref">includePrefix</dt>
			<dd>includePrefix of the new skin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddSkin</td>
		<td>(v2.0) Immediately after a new skin has been created</td>
		<td><dl>
			<dt class="ro">name</dt>
			<dd>name of the new skin</dd>
			<dt class="ro">description</dt>
			<dd>description of the new skin</dd>
			<dt class="ro">type</dt>
			<dd>content type of the skin</dd>
			<dt class="ro">includeMode</dt>
			<dd>includeMode of the new skin</dd>
			<dt class="ro">includePrefix</dt>
			<dd>includePrefix of the new skin</dd>
			<dt class="ro">skinid</dt>
			<dd>ID of the new skin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddBan</td>
		<td>(v2.0) Immediately before a new ban is added to a weblog</td>
		<td><dl>
			<dt class="ref">blogid</dt>
			<dd>ID of the blog</dd>
			<dt class="ref">iprange</dt>
			<dd>IP range to be banned</dd>
			<dt class="ref">reason</dt>
			<dd>textual message describing the reason for the ban</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddBan</td>
		<td>(v2.0) Immediately after a new ban has been added</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog</dd>
			<dt class="ro">iprange</dt>
			<dd>IP range to be banned</dd>
			<dt class="ro">reason</dt>
			<dd>textual message describing the reason for the ban</dd>
		</dl></td>
	</tr>

	<tr>
		<td>PreMoveItem</td>
		<td>(v2.0) Immediately before an item is moved to another blog/category</td>
		<td><dl>
			<dt class="ref">itemid</dt>
			<dd>ID of the item</dd>
			<dt class="ref">destblogid</dt>
			<dd>ID of the destination blog</dd>
			<dt class="ref">destcatid</dt>
			<dd>ID of the destination category</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostMoveItem</td>
		<td>(v2.0) Immediately after an item has been moved to another blog/category</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>ID of the item</dd>
			<dt class="ro">destblogid</dt>
			<dd>ID of the new blog</dd>
			<dt class="ro">destcatid</dt>
			<dd>ID of the new category</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreMoveCategory</td>
		<td>(v2.0) Immediately before a catgeory is moved to another blog</td>
		<td><dl>
			<dt class="ref">catid</dt>
			<dd>ID of the catgeory</dd>
			<dt class="ref obj">sourceblog</dt>
			<dd>source <code>BLOG</code> object</dd>
			<dt class="ref obj">destblog</dt>
			<dd>destination <code>BLOG</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostMoveCategory</td>
		<td>(v2.0) Immediately after a catgeory has been moved to another blog</td>
		<td><dl>
			<dt class="ro">catid</dt>
			<dd>ID of the catgeory</dd>
			<dt class="ref obj">sourceblog</dt>
			<dd>source <code>BLOG</code> object</dd>
			<dt class="ref obj">destblog</dt>
			<dd>destination <code>BLOG</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>MemberSettingsFormExtras</td>
		<td>(v2.0) On the member settings page. You can add your own forms here.
			<br /><br />
			Don't add too much data, and please generate <strong>valid XHTML</strong>, looking like this:
<pre class="example"><code>&lt;h4&gt;plugin name&lt;/h4&gt;
&lt;form method="post" action="..."&gt;&lt;p&gt;
your stuff
&lt;/p&gt;&lt;/form&gt;</code></pre>
			This way, multiple plugins can add options here while things keep a good structure. Also try to use prefixes for your fieldnames, in order to avoid nameclashes (e.g. <code>plug_tb_url</code>)

		</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd>reference to a <code>MEMBER</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>GeneralSettingsFormExtras</td>
		<td>(v2.0) On the general settings page. You can add your own forms here.
			<br /><br />
			Don't add too much data, and please generate <strong>valid XHTML</strong>, looking like this:
<pre class="example"><code>&lt;h4&gt;plugin name&lt;/h4&gt;
&lt;form method="post" action="..."&gt;&lt;p&gt;
your stuff
&lt;/p&gt;&lt;/form&gt;</code></pre>
			This way, multiple plugins can add options here while things keep a good structure. Also try to use prefixes for your fieldnames, in order to avoid nameclashes (e.g. <code>plug_tb_url</code>)

		</td>
		<td>None</td>
	</tr>
	<tr>
		<td>AdminPrePageHead</td>
		<td>(v2.5) On admin area pages, immediately before the page head is printed. This event could be used to add extra script/css includes in the head section</td>
		<td><dl>
			<dt class="ref">extrahead</dt>
			<dd>Extra information to be included in the head section of the HTML page. Append your extras here.</dd>
			<dt class="ro">action</dt>
			<dd>Currently executed action or pagetype</dd>
		</dl></td>
	</tr>
	<tr>
		<td>AdminPrePageFoot</td>
		<td>(v2.5) On admin area pages, immediately before the page footer is printed.</td>
		<td><dl>
			<dt class="ro">action</dt>
			<dd></dd>
		</dl>Currently executed action or pagetype</td>
	</tr>
	<tr>
		<td>PreSendContentType</td>
		<td>(v2.5) Immediately before a content type is being set in the HTTP header</td>
		<td><dl>
			<dt class="ref">contentType</dt>
			<dd>content type (e.g. <code>application/xhtml+xml</code>)</dd>
			<dt class="ref">charset</dt>
			<dd>Character set</dd>
			<dt class="ro">pageType</dt>
			<dd>String indicating which type of page we're displaying: <code>skin</code> (skinparts), <code>media</code> (media library), <code>admin-<em>action</em></code> (admin area), <code>bookmarklet-<em>action</em></code> (bookmarklet)</dd>
		</dl></td>
	</tr>
	<tr>
		<td>QuickMenu</td>
		<td>(v2.5) At the end of the Admin Area quick menu. This can be used to add extra plugin entries. To add entries, push associative arrays on the <code>options</code> array. An example can be found in the section about <a href="#admin">creating a plugin admin area</a>.</td>
		<td><dl>
			<dt class="ref">options</dt>
			<dd>Array</dd>
		</dl></td>
	</tr>
	<tr>
		<td>BookmarkletExtraHead</td>
		<td>(v2.5) Somewhere inside the <code>head</code> section of the bookmarklet XHTML code.</td>
		<td><dl>
			<dt class="ref">extrahead</dt>
			<dd>Information to be included in the <code>head</code> section of the XHTML code. Add your extras here.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>FormExtra</td>
		<td>(v3.2) Inside one of the comment, membermail or account activation forms. This event allows plugins to insert extra fields in the form. This event corresponds with the <code>ValidateForm</code> event that is fires when the form is handled.</td>
		<td><dl>
			<dt class="ro">type</dt>
			<dd>Type of the form from which the event fired.
				<ul>
					<li><code>activation</code></li>
					<li><code>additemform</code> (note: this is not the add item form from the admin area!)</li>
					<li><code>commentform-loggedin</code></li>
					<li><code>commentform-notloggedin</code></li>
					<li><code>membermailform-loggedin</code></li>
					<li><code>membermailform-notloggedin</code></li>
				</ul>
			</dd>
			<dt class="ro obj">member</dt>
			<dd>When <code>type</code> is <code>activation</code>, this field contains the details of the member that's being activated</dd>
		</dl></td>
	</tr>
	<tr>
		<td>ValidateForm</td>
		<td>(v3.2) Called when one of the comment, membermail or account activation forms is being handled. This event allows plugins to perform their own validation on the data, and prevent further handling if something is wrong. When used together with the <code>FormExtra</code> field, it can be used to add extra fields to forms.</td>
		<td><dl>
			<dt class="ro">type</dt>
			<dd>Type of the form being handled
				<ul>
					<li><code>membermail</code></li>
					<li><code>comment</code></li>
					<li><code>activation</code></li>
				</ul>
			</dd>
			<dt class="ref">error</dt>
			<dd>When the plugin wants to stop the handling of the form, it needs to fill out a non-empty error string message in this <code>error</code> field. This error message will then be presented to the user.</dd>
			<dt class="ref">comment</dt>
			<dd>On <code>comment</code>-type forms, contains an associative array with the comment data.</dd>
			<dt class="ref">spamcheck</dt>
			<dd>On <code>comment</code>-type forms, the resulting datastructure of the previously called <code>SpamCheck</code> event (associative array)</dd>
			<dt class="ro obj">member</dt>
			<dd>On <code>activation</code>-type forms, contains information about the member being activated.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>ParseURL</td>
		<td>(v3.22) Called before an URL is resolved from the Nucleus Core. This event allows Plugins to interpret URLs.</td>
		<td><dl>
			<dt class="ro">type</dt>
			<dd>Type of the page, e.g. item, blog, ...</dd>
			<dt class="ro">info</dt>
			<dd>The full URL which should be resolved (the name is derived from the old fashion variable <code>pathinfo</code>).</dd>
			<dt class="ref">complete</dt>
			<dd>Should be set to <b>true</b> if the plugin has resolved the URL and to <b>false</b> if the plugin hasn't resolved the URL.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>GenerateURL</td>
		<td>(v3.22) Called before an URL is output on the page. Allows plugins to rewrite the output URLs and offer an own URL logic.</td>
		<td><dl>
			<dt class="ro">type</dt>
			<dd>Type of the page, e.g. item, blog, ...</dd>
			<dt class="ro">params</dt>
			<dd>Parameters which should be added to the URL.</dd>
			<dt class="ref">completed</dt>
			<dd>Should be set to <b>true</b> if the plugin returns an URL and to <b>false</b> if the plugin don't returns an URL.</dd>
			<dt class="ref">url</dt>
			<dd>The URL itself which should be output from Nucleus.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>SpamCheck</td>
		<td>(v3.3) Called when a new comment is added. This event allows anti-spam plugins to mark this comment as spam. A complete descriptions of the <code>SpamCheck</code> event can be found in a seperate document: <a href='http://wakka.xiffy.nl/spamcheck_api'>SpamCheck API 2.0</a>.</td>
		<td><dl>
			<dt class="ref">spamcheck</dt>
			<dd>The spamcheck datastructure</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreMediaUpload</td>
		<td>(v3.3) Before an uploaded media file is written to the media directory.</td>
		<td><dl>
			<dt class="ref">collection</dt>
			<dd>The collection where the uploaded file should be saved.</dd>
			<dt class="ro">uploadfile</dt>
			<dd>The temporary name of the uploaded file.</dd>
			<dt class="ref">filename</dt>
			<dd>The filename under which the file should be saved.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostMediaUpload</td>
		<td>(v3.3) After an uploaded is written to the media directory.</td>
		<td><dl>
			<dt class="ro">collection</dt>
			<dd>The collection to which the uploaded file has been added.</dd>
			<dt class="ro">mediadir</dt>
			<dd>The media directory to which the uploaded file has been written.</dd>
			<dt class="ro">filename</dt>
			<dd>The filename under which the file has been saved.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>SendPing</td>
		<td>(v3.3) Called when a new item is added and the blog is configured to send ping (need NP_Ping installed). This event is used by NP_Ping to ping various weblog listing service (i.e. pingomatic.com)</td>
		<td><dl>
			<dt class="ref">blogid</dt>
			<dd>ID of the blog</dd>
		</dl></td>
	</tr>
	<tr>
		<td>JustPosted</td>
		<td>(v3.3) Called when a future post appears on the blog the first time. The event is trigger after a skin parse is completed</td>
		<td><dl>
			<dt class="ref">blogid</dt>
			<dd>ID of the blog</dd>
		</dl></td>
	</tr>
	<tr>
		<td>RegistrationFormExtraFields</td>
		<td>(v3.40) Called from createaccount.php after basic account fields, but before FormExtra event. This event can be used by plugins to add custom fields to the registration form. Plugins that subscribe to this event should also subscribe to PostRegister event to process the added fields. The parameters should be used to fit custom fields into existing format of registration form. Plugins should output the html code needed for their extra fields. For an example of using this event, see the NP_Profile plugin.</td>
		<td><dl>
			<dt class="ro">type</dt>
			<dd>String. Type of registration form. Normally, <code>createaccount.php</code>.</dd>
			<dt class="ro">prelabel</dt>
			<dd>HTML code or string that should be inserted <strong>before</strong> the field label.</dd>
			<dt class="ro">postlabel</dt>
			<dd>HTML code or string that should be inserted <strong>after</strong> the field label.</dd>
			<dt class="ro">prefield</dt>
			<dd>HTML code or string that should be inserted <strong>before</strong> the input field.</dd>
			<dt class="ro">postfield</dt>
			<dd>HTML code or string that should be inserted <strong>after</strong> the input field.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>TemplateExtraFields</td>
		<td>(v3.40) Called when templates are edited and updated from the admin area. Allows plugin developers to add fields to existing templates to encourage the use of the core template storage system to provide formatting for their output. It is the responsibility of the plugin authors to use the template fields they add and to provide the variables used in those fields. Plugins should also document their variables and provide for a default, either in the code or through a plugin option. <a href="http://forum.nucleuscms.org/viewtopic.php?p=87672#87672" title="Sample">Sample plugin using this event.</a></td>
		<td><dl>
			<dt class="ref">fields</dt>
			<dd>Associative Array. Key should be name of the plugin, i.e. <code>NP_TemplateTest</code>, and value should be an associative array with keys designating the template field name, and values designating the label used for the field. Template field names should be lowercase and incorporate the plugin name to avoid duplication of template field names.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreArchiveListItem</td>
		<td>(v3.40) Called right before the archive list is displayed. Allows plugin developers to add/modify template variables in the Archive List Item field of the template used for displaying archive lists. Plugins should document the variables added. </td>
		<td><dl>
			<dt class="ref">listitem</dt>
			<dd>Associative Array. The key represents the template variable, i.e. <code>month</code>, and the value of the array element is a string representing the value of the template variable. To add a variable, simply add an element to this array with a key-value pair representing the new variable.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreCategoryListItem</td>
		<td>(v3.40) Called right before the category list is displayed. Allows plugin developers to add/modify template variables in the Category List Item field of the template used for displaying category lists. Plugins should document the variables added. </td>
		<td><dl>
			<dt class="ref">listitem</dt>
			<dd>Associative Array. The key represents the template variable, i.e. <code>catname</code>, and the value of the array element is a string representing the value of the template variable. To add a variable, simply add an element to this array with a key-value pair representing the new variable.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreBlogListItem</td>
		<td>(v3.40) Called right before the blog list is displayed. Allows plugin developers to add/modify template variables in the Blog List Item field of the template used for displaying blog lists. Plugins should document the variables added. </td>
		<td><dl>
			<dt class="ref">listitem</dt>
			<dd>Associative Array. The key represents the template variable, i.e. <code>blogname</code>, and the value of the array element is a string representing the value of the template variable. To add a variable, simply add an element to this array with a key-value pair representing the new variable.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreTemplateRead</td>
		<td>(v3.40) Called right before a template is read and its parts returned. Allows plugin developers to change the name of the template being used. NP_MultiLanguage makes use of this event. </td>
		<td><dl>
			<dt class="ref">name</dt>
			<dd>String containing the name of the template being called.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>CustomLogin</td>
		<td>(v3.40) Called right before local (Nucleus) login. Allows plugin developers to customize the login process. This simplifies external authentication and permits using something beside the displayname, i.e. email address, to be used for the login name. </td>
		<td><dl>
			<dt class="ref">login</dt>
			<dd>String containing the name entered by user in login field. If this is other than the Nucleus mname (display name), it should be mapped by the plugin, after a successful authentication, to a valid mname corresponding to the authenticated member. Otherwise the authentication will last only one page and no cookies will be set.</dd>
			<dt class="ref">password</dt>
			<dd>String containing the password entered by user in password field.</dd>
			<dt class="ref">success</dt>
			<dd>Integer indicating whether the login is successful. 1 means success, 0 means unsuccessful. 0 is the default. The plugin should set this.</dd>
			<dt class="ref">allowlocal</dt>
			<dd>Integer indicating whether local authentication should be tried after an unsuccessful authentication by your plugin. 1 means yes, 0 means no. 1 is the default.</dd>
		</dl></td>
	</tr>

	<tr>
		<td>PrePasswordSet</td>
		<td>(v3.50) Called when user tries to set password in admin area or during activation. Allows for plugins to enforce password complexity rules.</td>
		<td><dl>
			<dt class="ro">password</dt>
			<dd>String containing the user-entered password.</dd>
			<dt class="ref">errormessage</dt>
			<dd>String containing the error message the user should see upon failure. Should be left blank if no validation error occurs.</dd>
			<dt class="ref">valid</dt>
			<dd>Boolean indicating whether the proposed password is valid. Default is true. Plugin code should check this value to verify it is not already false before processing a password</dd>
		</dl></td>
	</tr>
	
	<tr>
		<td>PostParseURL</td>
		<td>(v3.60) Triggers right after the url is fully parsed (by ParseURL in globalfunctions). Useful to tweak global variables before selector() runs or to set something based on path-related globals.</td>
		<td><dl>
			<dt class="ro">type</dt>
			<dd>Type of the page, e.g. item, blog, ...</dd>
			<dt class="ro">info</dt>
			<dd>The full URL which should be resolved (the name is derived from the old fashion variable <code>pathinfo</code>).</dd>
		</dl></td>
	</tr>
	
	<tr>
		<td>MediaUploadFormExtras</td>
		<td>(v3.60) Add fields to File Upload page of Nucleus Media Manager. All output should be valid XHTML 1.0. You must also subscribe to the PreMediaUpload event and get values from your added fields using requestVar(). </td>
		<td>No Data is passed.</td>
	</tr>
<!--	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr> -->
</table>



<h1>Saving options <a name="options" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>A series of methods are offered to make it easy for plugins to set and retrieve options. These options can be directly edited from inside the Nucleus admin area, taking the need away for the plugin to provide an admin area of its own, and avoiding that options need to be set inside the PHP file itself.</p>

<p>Options are available in different contexts:</p>

<ol>
	<li><strong>Global options</strong>: Editable on the admin area from the plugins section.</li>
	<li><strong>Blog options</strong>: Editable from the blogsettings pages.</li>
	<li><strong>Category options</strong>: Editable from the blogsettings pages (on the 'edit category' page).</li>
	<li><strong>Member options</strong>: Editable on the 'edit member' pages</li>
  <li><strong>Item options</strong>: Editable on the 'add item' or 'edit item' pages</li>
</ol>

<h2>Option types</h2>

<p>Several types of options are provided</p>

<dl>
	<dt>text</dt>
	<dd>Simple text</dd>
	<dt>yesno</dt>
	<dd>Either the value '<code>yes</code>' or the value '<code>no</code>' (on edit, shown as radio button)</dd>
	<dt>password</dt>
	<dd>Text field (starred on edit)</dd>
	<dt>textarea (v2.2)</dt>
	<dd>Text field with multiple rows and columns</dd>
	<dt>select (v2.2)</dt>
	<dd>Drop down menu. Needs extra info in the following form: <code>Option 1|value1|Option 2|value2|Option 3|value3</code>
	</dd>
</dl>

<h2>Option meta</h2>

<p>As of Nucleus v3.2, some option types can be limited to only accept certain values using option-metadata. This metadata is stored in the <code>$typeExtras</code>-field, and is a semicolon-seperated list of values. Note: In a select-option, the select list must be the first value in <code>$typeExtras</code>.</p>

<table><tr>
	<th>key</th>
	<th>explanation</th>
</tr><tr>
	<td><code>datatype</code></td>
	<td>Using '<code>datatype</code>' you can give some extra hints to Nucleus about the datatype you want to use. Currently only '<code>numerical</code>' is available. '<code>numerical</code>' will cause Nucleus to only accept numerical values for this option (using both client-side and server-side check) (available for optiontypes: '<code>select</code>' and '<code>text</code>')</td>
</tr><tr>
	<td><code>access</code></td>
	<td>If set to '<code>readonly</code>', the option will not be editable (available for optiontypes: '<code>text</code>' and '<code>textarea</code>')<br />
	If set to '<code>hidden</code>', the option will be completely hidden for the end-user (available for optiontypes: '<code>text</code>')</td>
</tr></table>

<p>some examples:</p>
<pre class="example"><code>// following code creates a text-option that only accepts numerical values
$this->createBlogOption('FooBar', 'foobar', 'text', '0', 'datatype=numerical');
// following code creates a select-option that only accepts numerical values
$this->createItemOption('FooBar', 'foobar', 'select', '0', '0|0|1|1|2|2;datatype=numerical');
// following code creates a textarea-option that is readonly
$this->createOption('FooBar', 'foobar', 'textarea', 'This textarea is readonly', 'access=readonly');
</code></pre>

<h2>Restrictions</h2>

<ol>
	<li>The name of an option can contain a maximum of 20 characters</li>
	<li>The description of an option can contain a maximum of 255 characters</li>
	<li>The value for an option has no limit (Prior to v2.5 the limit was 128 characters)</li>
  <li>The characters '=', '|' and ';' can not be used inside a select list (for a select-option), or in option-metadata</li>
</ol>

<h2>The methods</h2>

<h3>createOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p>Creates a new option in the <strong>global</strong> context</p>

<table><tr>
	<th>parameter</th>
	<th>value</th>
</tr><tr>
	<td>$name</td>
	<td>Option name</td>
</tr><tr>
	<td>$desc</td>
	<td>Textual description, to be shown on the page where options can be edited</td>
</tr><tr>
	<td>$type</td>
	<td>Option type (see above)</td>
</tr><tr>
	<td>$defValue</td>
	<td>Initial value</td>
</tr><tr>
	<td>$typeExtras</td>
	<td>Extra info on option type (see above)</td>
</tr></table>

<h3>[v2.2] createBlogOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p>Creates an option in the <strong>blog</strong> context (see <code>createOption</code>)</p>

<h3>[v2.2] createCategoryOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p>Creates an option in the <code>category</code> context (see <code>createOption</code>)</p>

<h3>[v2.2] createMemberOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p>Creates an option in the <code>member</code> context (see <code>createOption</code>)</p>

<h3>[v3.2] createItemOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p>Creates an option in the <code>item</code> context (see <code>createOption</code>)</p>

<h3>setOption($name, $value)</h3>

<p>changes the value of an option that was already in the database</p>

<table><tr>
	<th>parameter</th>
	<th>value</th>
</tr><tr>
	<td>$name</td>
	<td>Option name</td>
</tr><tr>
	<td>$value</td>
	<td>New value for option</td>
</tr></table>

<h3>[v2.2] setBlogOption($blogid, $name, $value)</h3>

<p>Changes the value for a blog option. The <code>blogid</code> attribute indicates for which blog the option is valid. (other options: see <code>setOption</code>)</p>

<h3>[v2.2] setCategoryOption($catid, $name, $value)</h3>

<p>Changes the value for a category option. The <code>catid</code> attribute indicates for which category the option is valid. (other options: see <code>setOption</code>)</p>

<h3>[v2.2] setMemberOption($memberid, $name, $value)</h3>

<p>Changes the value for a member option. The <code>memberid</code> attribute indicates for which member the option is valid. (other options: see <code>setOption</code>)</p>

<h3>[v3.2] setItemOption($itemid, $name, $value)</h3>

<p>Changes the value for an item option. The <code>itemid</code> attribute indicates for which item the option is valid. (other options: see <code>setOption</code>)</p>

<h3>getOption($name)</h3>

<p>Returns the value for an option in the database</p>

<table><tr>
	<th>parameter</th>
	<th>value</th>
</tr><tr>
	<td>$name</td>
	<td>Option name</td>
</tr></table>

<h3>[v2.2] getBlogOption($blogid, $name)</h3>

<p>Returns the value for a blog option. <code>blogid</code> indicates for which blog a value is requested (other parameters: see <code>getOption</code>)</p>

<h3>[v2.2] getCategoryOption($catid, $name)</h3>

<p>Returns the value for a category option. <code>catid</code> indicates for which category a value is requested (other parameters: see <code>getOption</code>)</p>

<h3>[v2.2] getMemberOption($memberid, $name)</h3>

<p>Returns the value for a member option. <code>memberid</code> indicates for which member a value is requested (other parameters: see <code>getOption</code>)</p>

<h3>[v3.2] getItemOption($itemid, $name)</h3>

<p>Returns the value for an item option. <code>itemid</code> indicates for which item a value is requested (other parameters: see <code>getOption</code>)</p>

<h3>deleteOption($name)</h3>

<p>Deletes an option from the database</p>

<table><tr>
	<th>parameter</th>
	<th>value</th>
</tr><tr>
	<td>$name</td>
	<td>Option name</td>
</tr></table>

<h3>[v2.2] deleteBlogOption($name)</h3>

<p>Deletes a blog option (see <code>deleteOption</code>)</p>

<h3>[v2.2] deleteCategoryOption($name)</h3>

<p>Deletes a category option (see <code>deleteOption</code>)</p>

<h3>[v2.2] deleteMemberOption($name)</h3>

<p>Deletes a member option (see <code>deleteOption</code>)</p>

<h3>[v3.2] deleteItemOption($name)</h3>

<p>Deletes an item option (see <code>deleteOption</code>)</p>

<h3>[v2.2] getAllBlogOptions($name)</h3>

<p>Returns all values for a given blog option. The result is an associative array with a value for each existing blogid</p>

<h3>[v2.2] getAllCategoryOptions($name)</h3>

<p>Returns all values for a given category option. The result is an associative array with a value for each existing catid</p>

<h3>[v2.2] getAllMemberOptions($name)</h3>

<p>Returns all values for a given member option. The result is an associative array with a value for each existing memberid</p>

<h3>[v3.2] getAllItemOptions($name)</h3>

<p>Returns all values for a given item option. The result is an associative array with a value for each existing itemid</p>

<h3>[v3.2] getBlogOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>Returns the top of the values for a given option. The result is an array where every element is an array with a value ('value') for each blogid ('id')</p>

<table><tr>
	<th>parameter</th>
	<th>value</th>
</tr><tr>
	<td>$name</td>
	<td>Option name</td>
</tr><tr>
	<td>$amount</td>
	<td>The amount of options you want</td>
</tr><tr>
	<td>$sort</td>
	<td>Sort ascending ('asc') or descending ('desc')</td>
</tr></table>

<h3>[v3.2] getMemberOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>Returns the top of the values for a given option. The result is an array where every element is an array with a value ('value') for each memberid ('id') (parameters: see <code>getBlogOptionTop</code>)</p>

<h3>[v3.2] getCategoryOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>Returns the top of the values for a given option. The result is an array where every element is an array with a value ('value') for each categoryid ('id') (parameters: see <code>getBlogOptionTop</code>)</p>

<h3>[v3.2] getItemOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>Returns the top of the values for a given option. The result is an array where every element is an array with a value ('value') for each itemid ('id') (parameters: see <code>getBlogOptionTop</code>)</p>

<div class="note">
<b>Note:</b> You can't call these functions from inside constructors of plugin classes. If you want to execute them when the plugin is loaded, place them in the <code>init()</code> method instead.
</div>

<h1>Database tables <a name="tables" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>Access to Nucleus tables</h2>

<p>Up to v2.0, accessing the nucleus tables was just a matter of performing an SQL query on one of the <code>nucleus_</code> tables. Since it is possible to use a custom table name in Nucleus versions >2.0, some precautions are needed in plugin development:</p>

<p>As of v3.5, Nucleus is moving toward support for database handlers different from MySQL, such as PDO. Though, this support is beta in version 3.5, plugin developers need to start making their plugins compatible with the new sql_* api used to implement the generic database calls. 
Essentially, you need onnly replace any mysql_* functions with sql_*, e.g. <code>mysql_fetch_assoc($result)</code> becomes <code>sql_fetch_assoc($result)</code>. 
you must do this for every interaction with the database. Be sure to indicate that you support the SqlApi feature as indicated below, and that you set the minNucleusVersion to 350, like this: <br /><code>function getMinNucleusVersion( return '350';)</code></p>

<ol>
	<li>Instead of using a fixed tablename like <code>nucleus_item</code>, use the global function <code>sql_table('item')</code> to generate the prefixed tablename</li>
	<li>Make sure your plugin returns <code>1</code> (<code>true</code>) when <code>supportsFeature('SqlTablePrefix')</code> is called on it. If it doesn't, you won't be able to load the plugin on Nucleus versions > 2.0 when a custom prefix has been set (as a precaution)</li>
	<li>v3.5+. Make sure your plugin returns <code>1</code> (<code>true</code>) when <code>supportsFeature('SqlApi')</code> is called on it. If it doesn't, you won't be able to load the plugin on Nucleus versions > 3.5 when a user is using a non-mysql database backend (as a precaution)</li>
</ol>

<p class="note">Note that the <code>sql_table</code> global function in not available in Nucleus versions up to v2.0. If you use this method and want your plugin to work on Nucleus versions &lt;= 2.0, add the following snippet of code on top of your plugin class:</p>

<pre class="example"><code>&lt;?php

// plugin needs to work on Nucleus versions &amp;=2.0 as well
if (!function_exists('sql_table'))
{
	function sql_table($name) {
		return 'nucleus_' . $name;
	}
}

class NP_HelloWorld extends NucleusPlugin {
...
}

?&gt;</code></pre>

<h2>Your own tables</h2>

<p>If your plugin needs database tables of it's own, you should create them in the <code>install</code> method and remove them in the <code>unInstall</code> method.</p>

<p>Some pointers</p>
<ul>
	<li>Consider using a table name like <code>nucleus_plug_<i>plugname</i></code> to avoid conflicts with other plugins. Generate them through <code>sql_table('plug_plugname')</code> to make it work with custom prefixes</li>
	<li>You don't need to make a database connection yourself. You can execute queries using the Nucleus function <code>sql_query()</code> which is a wrapper for the PHP command <code>mysql_query()</code></li>
	<li>If you do make a database connection yourself, make sure to restore the connection with the Nucleus database afterwards. You can do this by calling <code>sql_connect()</code> at the end of your function. It might also be good to do this from the constructor, to avoid reconnecting constantly. You could then save your link identifier in <code>$this->db</code> and pass that along with every query.</li>
	<li>Also redefine the <code>getTableList()</code> method to make sure your table gets backed up when using the backup function.</li>
	<li>It's a good idea to make the removal of your database tables optional. This will allow your users to temporarily remove your plugin without losing the data. For instance, you may need to make changes to options or database tables requiring that the install() method be run to execute code neccessary to modify existing tables or options. This will require that your users uninstall the old version and then install the new version and losing their data in the process. To make the deletion of your tables optional, you can add an option like this in install():
	<pre class="example"><code>$this->createOption('del_uninstall', 'Delete NP_MyPlugin data tables on uninstall?', 'yesno','no');</code></pre>
	and this snippet in uninstall():
	<pre class="example"><code>if ($this->getOption('del_uninstall') == 'yes')	{
	foreach ($this->getTableList() as $table) {
		sql_query("DROP TABLE $table");
	}
}</code></pre></li>
</ul>



<h1>Plugin Admin Area <a name="admin" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>As of Nucleus v2.5, plugins can create admin area pages that integrate with the Nucleus admin area. These pages can be accessed either from the plugin admin page, or the quickmenu on the left.</p>

<h2>Basics</h2>

<p>To provide an admin area, you'll need to take these steps:</p>

<ol>
  <li>Create a subdirectory of the plugins directory, and name it <strong>pluginname</strong> if your plugin is <code>NP_PluginName</code>. Note that the name should be <strong>lowercase</strong>!</li>
  <li>
	In that directory, create a file called <strong>index.php</strong>, which looks like this:
	<pre><code>&lt;?php

	// if your 'plugin' directory is not in the default location,
	// edit this variable to point to your site directory
	// (where config.php is)
	$strRel = '../../../';

	include($strRel . 'config.php');
	if (!$member->isLoggedIn())
		doError('You\'re not logged in.');

	include($DIR_LIBS . 'PLUGINADMIN.php');

	// create the admin area page
	$oPluginAdmin = new PluginAdmin('<strong>PluginName</strong>');
	$oPluginAdmin->start();

	echo '&lt;h2&gt;Plugin Name&lt;/h2&gt;';

	echo '&lt;p&gt;<strong>Page contents here</strong>&lt;p&gt;';

	$oPluginAdmin->end();

?&gt;</code></pre>
  </li>
  <li>
	Subscribe to the <code>QuickMenu</code> event and add this code in your plugin:
	<pre><code>function event_QuickMenu(&amp;$data) {
		array_push(
			$data['options'],
			array(
				'title' => '<strong>Plugin Name</strong>',
				'url' => $this->getAdminURL(),
				'tooltip' => '<strong>Tooltip text</strong>'
			)
		);
	}</code></pre>
  </li>
  <li>
	Implement this method in your plugin:
	<pre><code>function hasAdminArea()
{
	return 1;
}</code></pre>
  </li>
  <li> Optional. Make the <code>QuickMenu</code> entry optional, and restrict who sees it. The following assumes that an option, of type <code>yesno</code> and called <code>quickmenu</code>, exists in install(). It also will restrict viewing of the <code>QuickMenu</code> entry to super-admins and to blog-admins.
	<pre class="example"><code>function event_QuickMenu(&$data) {
    // only show when option enabled
    if ($this->getOption('quickmenu') != 'yes') return;
    global $member;
    if (!$member->isAdmin() && !count($member->getAdminBlogs())) return;
    array_push($data['options'],
      	array('title' => 'PluginName',
       	'url' => $this->getAdminURL(),
       	'tooltip' => 'Administer NP_PluginName'));
}</code></pre>
  </li>
</ol>

<h2>Considerations</h2>

<ul>
 <li>Don't just add an entry to the quick menu because it is possible. Imagine having 100 plugins installed, which all add an entry in the menu. This would result in a real mess. So, even if you add an entry in the menu, please consider adding an option (global or member-level) to enable/disable the quick menu entry.</li>
 <li>The <code>$strRel</code> variable in the <code>index.php</code> needs to be adapted manually if the plugins directory is not located in <code>nucleus/plugins/</code></li>
 <li>Make sure your admin area outputs <strong>valid XHTML</strong>. If not, the page will be broken in Gecko-based (Mozilla etc) browsers.</li>
</ul>

<h2>The PluginAdmin class</h2>

<p>The purpose of the <code>PluginAdmin</code> is to help you. Once created, you can use <code>$oPluginAdmin->plugin</code> to access the instance of your plugin.</p>

<h1>Plugin HelpPage <a name="help" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>As of Nucleus v3.2 plugins can provide a helppage with an overview of the plugins' functionality, the available skinvars and templatevars, where to get more info,...</p>

<p>The helppage will be accessible from the plugin overview in the admin area.</p>

<h2>Basics</h2>
<p>To provide a helppage, you'll need take these steps:</p>
<ol>
<li>Create a subdirectory of the plugins directory, and name it pluginname if your plugin is NP_PluginName. Note that the name should be lowercase! This is actually the same directory as for the <a href="#admin">admin area</a>.</li>
<li>In that directory, create a file called help.html. In this file you can document your plugin. This is a good template to start from:
<pre><code>&lt;h3&gt;Plugin overview&lt;/h3&gt;

&lt;p&gt;The only purpose of this plugin is to show how the plugin helppages work&lt;/p&gt;

&lt;h3&gt;Installation&lt;/h3&gt;

&lt;p&gt;If you can read this you correctly installed the plugin :-)&lt;/p&gt;

&lt;h3&gt;SkinVars&lt;/h3&gt;

&lt;p&gt;Because this plugin is only a testcase it doesn't has any skinvars/templatevars but suppose it would have:

&lt;ul&gt;&lt;li&gt;&lt;b&gt;&lt;%HelpPageTestCase1%&gt;&lt;/b&gt;: does something&lt;/li&gt;
&lt;li&gt;&lt;b&gt;&lt;%HelpPageTestCase1(foobar)%&gt;&lt;/b&gt;: does something else&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;

&lt;h3&gt;Support and Bug reports&lt;/h3&gt;

&lt;p&gt;For additional support and/or bug reports please use this forum thread:
&lt;a href="http://forum.nucleuscms.org/viewtopic.php?t=&lt;TOPIC_ID_GOES_HERE&gt;"&gt;
http://forum.nucleuscms.org/viewtopic.php?t=&lt;TOPIC_ID_GOES_HERE&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Version History&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;Version 0.1: initial testcaseversion&lt;/li&gt;
&lt;li&gt;Version 0.0: pre-initial version ;-)&lt;/li&gt;&lt;/ul&gt;</code></pre>
</li>
<li>Return a value larger than 0 for supportsFeature('HelpPage'):
<pre><code>function supportsFeature($what) {
	switch($what) {
	case 'HelpPage':
		return 1;
	  default:
		return 0;
	}
  }</code></pre>
</li>
</ol>

<h1>Plugin Dependency Check <a name="dependency" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>Starting from 3.2, a new plugin interface is added to allow one to declare any dependency on other plugin(s). This is useful for any
plugin that requires another plugin to function. It is particularly useful for a plugin to detect broken dependencies that prevent if from functioning properly.</p>

<h2>How to write a plugin that utilizes this function</h2>

<p>Let's start from a real world example:</p>

<p>NP_PageLinkList depends on NP_BlogWithOffset to function, so we want to make sure a user cannot install NP_PageLinkList whithout first installing
NP_BlogWithOffset. With this API, Nucleus offers a way for a plugin to detect any missing dependency before it is installed.</p>

<p>In this case, we want to code into NP_PageLinkList to mark that it requires NP_BlogWithOffset. When the plugin is installed, the core calls a
function in the plugin called <code>getPluginDep()</code>. This function returns a list of plugin it requires, and the core will check against all installed plugins and
refuse to install the plugin if a dependency is missing.</p>

<p>All we have to do is add this function to NP_PageLinkList:</p>

<pre><code>function getPluginDep() {
	 return array('NP_BlogWithOffset');
}</code></pre>

<p>The plugin dependency check also prevent a plugin from being uninstalled if other plugins have a dependancy on it.</p>

<h1>Internationalizing Your Plugin <a name="internationalization" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>Internationalization of a plugin allows your plugin to be easily used by people all over the world, people who do not 
speak the same language as you do. It requires a little additional work for you, but makes translating the output of your plugin 
as easy as translating a few phrases in a text file. Below is a description of the standard method suggested for use by Nucleus plugins. 
Thanks to Andy Matsubara for the instructions.</p>

<ol>
	<li><strong>Develop your plugin</strong>

At first, it is easier to develop it in your language. Use of language files is recommended after the plugin becomes stable.</li>
	<li><strong>Create plugin directory</strong>

If your plugin name is NP_AbcDef, the plugin directory name is abcdef (always lower case).</li>
	<li><strong>Create language files</strong>

Create the language files in the directory of your plugin. The name of the language file must be the same as that of the Nucleus language file name. For example, english.php is for English and default use. japanese-utf8.php for Japanese(UTF-Cool,japanese-euc.php for Japanese(EUC-JP).</li>
	<li><strong>Define strings</strong>

Define strings like below in the language file:

<pre class="example"><code>&lt;?php
define('_ABCDEF_MESSAGENAME',                  'actual strings in the language');
  . . .
?&gt;</code></pre>

You have to define them for all static strings in your plugin. As defined name is used globally in the environment, it is recommended to have a prefix derived from the plugin name(in this case _ABCDEF).</li>
	<li><strong>Replace static strings</strong>

Replace static strings in your plugin with the defined names so they will change according to the language file.</li>
	<li><strong>Create init method</strong>

Make the init method in the plugin like below

<pre class="example"><code>   function init() {
      // include language file for this plugin
      $language = preg_replace( '#[\\|/]#', '', getLanguageName());
      if (file_exists($this->getDirectory().$language.'.php'))
         include_once($this->getDirectory().$language.'.php');
      else
         include_once($this->getDirectory().'english.php');
   }</code></pre>
</li>
This logic is same as Nucleus language file setting.
	<li><strong>Add language files</strong>

As English is the default language, it is recommended to have at least the English version.	</li>
</ol>



<h1>Formatting your SkinVar output <a name="skinvar-formatting" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>Some great plugin ideas never receive general use simply because the output generated by the <code>doSkinVar()</code> method is not flexible enough to meet the needs of 
different skins or URL schemes. Nucleus provides some tools to help you generalize your output in ways that allow each user to fit it to his or her needs.</p>

<p>To create links to Nucleus pages, such as blogs, categories, items, member details, action.php, admin area, or the plugin admin page, use the built in Nucleus functions 
and global variables described below:</p>

<table summary="An overview of functions and variables useful in creating links to Nucleus pages">
	<caption>Functions and variables useful in creating links to Nucleus pages</caption>
	<tr>
		<th>Name</th><th>What</th><th>Parameters</th><th>Description</th>
	</tr>
	<tr>
		<td><code>$CONF['AdminURL']</code></td>
		<td>Global variable</td>
		<td>None</td>
		<td>Full URL to the Nucleus Admin Area</td>
	</tr>
	<tr>
		<td><code>$CONF['PluginURL']</code></td>
		<td>Global variable</td>
		<td>None</td>
		<td>Full URL to the Nucleus plugins directory. Use it to link to a plugin's admin page, like this <code>$CONF['PluginURL'].'pluginname/'</code></td>
	</tr>
	<tr>
		<td><code>$CONF['ActionURL']</code></td>
		<td>Global variable</td>
		<td>None</td>
		<td>Full URL to the Nucleus action.php file</td>
	</tr>
	<tr>
		<td><code>$CONF['MediaURL']</code></td>
		<td>Global variable</td>
		<td>None</td>
		<td>Full URL to the Nucleus media folder</td>
	</tr>
	<tr>
		<td><code>$CONF['SkinsURL']</code></td>
		<td>Global variable</td>
		<td>None</td>
		<td>Full URL to the Nucleus skins folder</td>
	</tr>
	<tr>
		<td><code>$CONF['IndexURL']</code></td>
		<td>Global variable</td>
		<td>None</td>
		<td>Full URL to the main Nucleus directory.</td>
	</tr>
	<tr>
		<td><code>$DIR_NUCLEUS</code></td>
		<td>Global variable</td>
		<td>None</td>
		<td>Full system path to the Nucleus Admin folder</td>
	</tr>
	<tr>
		<td><code>$DIR_SKINS</code></td>
		<td>Global variable</td>
		<td>None</td>
		<td>Full system path to the Nucleus skins folder</td>
	</tr>
	<tr>
		<td><code>$DIR_MEDIA</code></td>
		<td>Global variable</td>
		<td>None</td>
		<td>Full system path to the Nucleus media folder</td>
	</tr>
	<tr>
		<td><code>$DIR_PLUGINS</code></td>
		<td>Global variable</td>
		<td>None</td>
		<td>Full system path to the Nucleus plugins folder</td>
	</tr>
	<tr>
		<td><code>$DIR_LANG</code></td>
		<td>Global variable</td>
		<td>None</td>
		<td>Full system path to the Nucleus language folder</td>
	</tr>
	<tr>
		<td><code>$DIR_LIBS</code></td>
		<td>Global variable</td>
		<td>None</td>
		<td>Full system path to the Nucleus libs folder</td>
	</tr>
	<tr>
		<td><code>getAdminURL()</code></td>
		<td>method, PLUGIN class</td>
		<td>None</td>
		<td>Returns the URL of where the admin area of the plugin is located (if there is no such admin area, this information is invalid)</td>
	</tr>
	<tr>
		<td><code>getDirectory()</code></td>
		<td>method, PLUGIN class</td>
		<td>None</td>
		<td>Returns the full system path where the extra files for the plugin are stored (if there are no such files, this information makes no sense). The result is something like ".../nucleus/plugins/plugname/"</td>
	</tr>
	<tr>
		<td><code>createItemLink($itemid, $extra = '')</code></td>
		<td>Global function</td>
		<td><code>$itemid</code> Integer. ID of item being linked.<br />
			<code>$extra</code> Associative Array. Containing key-value pairs corresponding to additional parameters-values that should appear in the link.
		</td>
		<td>Returns the full URL, in scheme chosen by user, of item indicated by <code>$itemid</code></td>
	</tr>
	<tr>
		<td><code>createMemberLink($memberid, $extra = '')</code></td>
		<td>Global function</td>
		<td><code>$memberid</code> Integer. ID of member being linked.<br />
			<code>$extra</code> Associative Array. Containing key-value pairs corresponding to additional parameters-values that should appear in the link.
		</td>
		<td>Returns the full URL, in scheme chosen by user, of member page indicated by <code>$memberid</code></td>
	</tr>
	<tr>
		<td><code>createCategoryLink($catid, $extra = '')</code></td>
		<td>Global function</td>
		<td><code>$catid</code> Integer. ID of category being linked.<br />
			<code>$extra</code> Associative Array. Containing key-value pairs corresponding to additional parameters-values that should appear in the link.
		</td>
		<td>Returns the full URL, in scheme chosen by user, of category index page indicated by <code>$catid</code></td>
	</tr>
	<tr>
		<td><code>createArchiveListLink($blogid = '', $extra = '')</code></td>
		<td>Global function</td>
		<td><code>$blogid</code> Integer. ID of blog whose archivelist is being linked.<br />
			<code>$extra</code> Associative Array. Containing key-value pairs corresponding to additional parameters-values that should appear in the link.
		</td>
		<td>Returns the full URL, in scheme chosen by user, of archivelist page indicated by <code>$blogid</code></td>
	</tr>
	<tr>
		<td><code>createArchiveLink($blogid, $archive, $extra = '')</code></td>
		<td>Global function</td>
		<td><code>$blogid</code> Integer. ID of blog whose archive is being linked.<br />
			<code>$archive</code> String. Valid archive parameter for date (year-month) being linked.<br />
			<code>$extra</code> Associative Array. Containing key-value pairs corresponding to additional parameters-values that should appear in the link.
		</td>
		<td>Returns the full URL, in scheme chosen by user, of archive page indicated by <code>$blogid</code> and <code>$archive</code></td>
	</tr>
	<tr>
		<td><code>createBlogidLink($blogid, $extra = '')</code></td>
		<td>Global function</td>
		<td><code>$blogid</code> Integer. ID of blog being linked.<br />
			<code>$extra</code> Associative Array. Containing key-value pairs corresponding to additional parameters-values that should appear in the link.
		</td>
		<td>Returns the full URL, in scheme chosen by user, of main index page indicated by <code>$blogid</code></td>
	</tr>
</table>

<p>Using a template to format your output is always a good idea. You may want to output an unordered list, but another user may want the same data 
separated by a simple character, or other unique format. Nucleus provides two ways to create and store the template data. In both 
examples below, we will be creating a template with 2 variables, <code>&lt;%foo%&gt;</code> and <code>&lt;%bar%&gt;</code>.</p>

<ol>
	<li><strong>Using Plugin Options</strong>. This method may be the simplest and will work on all versions 3.2 and higher. It's 
	big disadvantage is that plugin options are deleted during an uninstall, so your users may lose customizations during an upgrade of 
	your plugin. Simply create an option in the <code>install()</code> method like the following:
	<pre class="example"><code>$this->createOption('my_template', 
		'Template used to format output of plugin.', 
		'textarea', 
		'&lt;li&gt;&lt;%foo%&gt; loves &lt;%bar%&gt;&lt;/li&gt;');</code></pre>
	Then in the <code>doSkinVar()</code> method, determine the values of <code>foo</code> and <code>bar</code> and fill the template like this:
	<pre class="example"><code>$mytemplate = $this->getOption('my_template');
$couples = array(
			array(
				'foo'=>'Ricky',
				'bar'=>'Lucy'),
			array(
				'foo'=>'Sid',
				'bar'=>'Nancy'),
			array(
				'foo'=>'Mickey',
				'bar'=>'Minnie')
			);
foreach ($couples as $values) {
	echo TEMPLATE::fill($mytemplate,$values);
}</code></pre>
	Now the skinvar for our plugin <code>&lt;%TemplateTest%&gt;</code> will output three lines like this:
	<pre class="example"><code>&lt;li&gt;Ricky loves Lucy&lt;/li&gt;
&lt;li&gt;Sid loves Nancy&lt;/li&gt;
&lt;li&gt;Mickey loves Minnie&lt;/li&gt;</code></pre>
	</li>
	
	<li><strong>Using Nucleus Core Template System</strong>. This method will only work with versions 3.4 and higher. It has the advantage of 
	being using the database-stored template system and can be exported like other template fields. For a full sample plugin using this method, 
	see this <a href="http://forum.nucleuscms.org/viewtopic.php?p=87672#87672" title="Sample">thread from the support forum</a>. A summary is given here. 
	First, create the option in <code>install()</code> as in method 1, but now we will use it as a default.
	<pre class="example"><code>$this->createOption('my_template', 
		'Template used to format output of plugin.', 
		'textarea', 
		'&lt;li&gt;&lt;%foo%&gt; loves &lt;%bar%&gt;&lt;/li&gt;');</code></pre>
	Then, subscribe to the <code>TemplateExtraFields</code> event like this:
	<pre class="example"><code>function getEventList() { return array('TemplateExtraFields'); }</code></pre>
	Then, create a <code>event_TemplateExtraFields</code> method in your plugin, like this:
	<pre class="example"><code>function event_TemplateExtraFields(&$data) {
    /* Add an element in the $data['fields'] array using your plugin name as the key 
	and an associative array containing the field name and field label*/
    /* note that your field names should be lowercase and include the name 
	of your template as shown below. This will ensure that all template field names are unique. */
    $data['fields']['NP_TemplateTest'] = array(
        'templatetest_body'=>'TemplateTest Body'
    );
}</code></pre>
	Then, in the <code>doSkinVar()</code> method, you need to retrieve the template and fill it. Note the skinvar now needs to take 
	the template name as a parameter.
	<pre class="example"><code>function doSkinVar($skinType,$template = '') {
	global $blog, $CONF, $manager,$member;

	$template =& $manager->getTemplate($template);
	if (trim($template['templatetest_body']) == '')
		$template['templatetest_body'] = $this->getOption('my_template');
		
	$couples = array(
			array(
				'foo'=>'Ricky',
				'bar'=>'Lucy'),
			array(
				'foo'=>'Sid',
				'bar'=>'Nancy'),
			array(
				'foo'=>'Mickey',
				'bar'=>'Minnie')
			);
	foreach ($couples as $values) {
		echo TEMPLATE::fill($template['templatetest_body'],$values);
	}	
}</code></pre>
	Here, the user needs to go to the template he wants to use and enter the formatting he desires into the TemplateTest Body field. 
	For our purposes, we are using the default/index template. He may enter something like this:
	<pre class="example"><code>&lt;li&gt;&lt;%foo%&gt; loves &lt;%bar%&gt;!!!&lt;/li&gt;</code></pre>
	And using a SkinVar like <code>&lt;%TemplateTest(default/index)%&gt;</code> will output this:
	<pre class="example"><code>&lt;li&gt;Ricky loves Lucy!!!&lt;/li&gt;
&lt;li&gt;Sid loves Nancy!!!&lt;/li&gt;
&lt;li&gt;Mickey loves Minnie!!!&lt;/li&gt;</code></pre>
	</li>
	
	<li><strong>Formatting Items Using Regular Template</strong>. This applies only to versions 3.40 and higher and for 
	plugins which output items. It has the advantage of using the existing Item fields in the core template system, 
	just like the <code>&lt;%blog%&gt;</code> SkinVar does. This requires the use of a method in the BLOG class called 
	<code>readLogFromList()</code> and requires that you input an array of itemids and a template name. If you need to 
	add variables to the template, you can do so using the <code>doTemplateVar()</code> method. Here is an example of 
	a <code>doSkinVar()</code> method that uses this technique. It takes 4 itemids as parameters, then outputs those four 
	items using the default/index template
	<pre class="example"><code>function doSkinVar($skinType,$item1 = 0,$item2 = 0,$item3 = 0,$item4 = 0) {
	global $blog;
	$highlight = '';
	$template = 'default/index';
	$item_array = array($item1,$item2,$item3,$item4);
	$blog->readLogFromList($item_array, $template);
}</code></pre>
	
	</li>
</ol>


<h1>Additional Reading <a name="additional-reading" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>As this document is intended to get you started, there are other resources available that offer additional insight.</p>
<ul>
<li><a href="http://wiki.nucleuscms.org/plugindev:index" title="Development Wiki">Development Wiki</a></li>
<li><a href="sqltables.html" title="Database Tables">Nucleus Database Table Structure</a></li>
<!-- <li><a href="" title=""></a></li> -->
</ul>

<!--
<pre class="example"><code></code></pre>
<pre class="example"><code></code></pre>
<pre class="example"><code></code></pre>
<pre class="example"><code></code></pre>
-->

</body>
</html>
